<https://gongfukangee.github.io/2019/04/03/BloomFilter/#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86>

# 布隆过滤器原理

> HashMap 确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。
> 但是 HashMap 的实现也有缺点，例如`存储容量占比高`

布隆过滤器的原理是，当一个元素被加入集合时，通过`K个散列函数`将这个元素映射成一个位数组中的K个点，把它们置为1。
检索时，我们只要看看这些点`是不是都是1就（大约）`知道集合中有没有它了：
如果`这些点有任何一个0`，则被检元素`一定不在`；如果`都是1`，则被检`元素很可能在`。这就是布隆过滤器的基本思想。

> 极端情况下，当布隆过滤器没有空闲空间时（满），每一次查询都会返回 true 。

> 传统的布隆过滤器并不支持删除操作

布隆过滤器是用来`判断一个元素`是否出现在`给定集合中`的重要工具， 具有快速，比哈希表更`节省空间`等优点，而缺点是存在一定的`误识别率`（fast-positive），
也就是它可能会把不是集合内的元素判定为存在于集合内，不过这样的概率相当小。

其原理也比较简单，如图所示，S 集合中有 n 个元素，利用 `k 个哈希函数`， 
将 S 中的每个元素映射到一个长度为 m 的位(bit) 数组 B 中的不同位置上， 
这些位置上的二进制数均置为 1，如果待检测的元素经过这 k
个哈希函数的映射后，发现其 `k 个位置`哈希的二进制数`不全是1` ，那么这个元素`一定不在集合` S 中，
反之该元素可能是 S 中的某一个元素。

根据前面的描述可以看到，为了估算出需要多少个哈希函数，已经创建长度为多少的 bit 数组合适，
在构造一个布隆过滤器时，需要传入两个参数，即可以接收的误判率 fpp 和元素总个数 m

关于误差的计算，可以按照一下的方法：

假定布隆过滤器有 m 比特，里面有 n 个元素，每个元素对应 k 个信息指纹的 hash 函数，
在这个布隆过滤器插入一个元素，
那么比特位被设置成 1 的概率为 1/m，它依然为 0 的概率为 1 - 1/m，那么 k
个哈希函数都没有把他设置成 1 的概率为 (1-1/m)^k ，一个比特在插入了 n 个元素后，被设置为 1 的概率为 1 - (1/m)^kn


## 实践例子

