
<https://www.infoq.cn/article/ukoqjkuwr0v0cs7u6p8o>

<https://www.jianshu.com/p/650c9878dee7>

<https://juejin.cn/post/6854573219157196807>

# Kafka凭什么速度那么快(写盘原理)

> 顺序写磁盘、大量使用内存页 、零拷贝技术的使用、消息压缩及批量发送


- 顺序写入

- Memory Mapped Files 内存映射文件
  
- 基于 sendfile 实现 Zero Copy(零拷贝读取)

- 批量压缩

> mmap: Memory Mapped Files 被翻译成 `内存映射文件` 
  它的工作原理是直接利用操作`系统的 Page` 来实现文件到`物理内存的直接映射`。(虚拟内存)

## 概述
Kafka作为一个支持大数据量写入写出的消息队列，由于是基于Scala和Java实现的，
而Scala和Java均需要在JVM上运行，所以如果是基于内存的方式，
即JVM的堆来进行数据存储则需要开辟很大的堆来支持数据读写，从而会`导致GC频繁影响性能`。
考虑到这些因素，kafka是`使用磁盘`而不是`kafka服务器broker进程内存`来进行数据存储，
并且基于`磁盘顺序读写`和`MMAP技术(零拷贝读取)`来实现高性能。

## Kafka的高性能磁盘读写实现原理

###  顺序写入
硬盘是`机械结构`，每次读写都会`寻址->写入`，其中寻址是一个“机械动作”，它是最耗时的。
所以硬盘最讨厌随机 I/O，最喜欢`顺序 I/O`。为了提高读写硬盘的速度，`Kafka 就是使用顺序 I/O`。（rocketMQ 也是一样）

Kafka 的数据`并不是实时的写入硬盘` ，它充分利用了现代操作系统`分页存储`来利用内存提高 I/O 效率。

#### Kafka 是如何写入数据的
每一个 Partition 其实都是一个文件 ，收到消息后 Kafka 会把数据插`入到文件末尾`

这种方法有一个缺陷——没有办法删除数据 ，所以 `Kafka 是不会删除数据的`，
它会把所有的数据都保留下来，每个消费者（Consumer）对每个 Topic 都有一个 `offset` 用来表示读取到了`第几条数据 `

如果不删除硬盘肯定会被撑满，所以 Kakfa 提供了`两种策略来删除数据`(在配置文档里进行配置)：
```
一是基于时间；
二是基于 partition 文件大小。
```
### Memory Mapped Files 内存映射文件

可知访问`磁盘文件`会将数据加载到`页缓存`中，但是页缓存属于`内核空间`，用户空间访问不了，
因此数据还需要`拷贝`到用户空间缓冲区。

mmap文件映射：就是将`程序虚拟页面`直接`映射`到`页缓存`上，这样就`无需有内核态再往用户态的拷贝`，
而且也避免了重复数据的产生。并且也不必再通过调用read或write方法对文件进行读写，
可以通过`映射地址`加偏移量的方式直接操作。

### 基于 sendfile 实现 Zero Copy

Kafka 把所有的消息都存放在一个一个的文件中，当消费者需要数据的时候 Kafka 直接把文件发送给消费者，
配合 mmap 作为`文件读写`方式，直接把它传给 sendfile。

### 批量压缩

- Kafka 使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩

- Kafka 允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩

- Kafka 支持多种压缩协议，包括 Gzip 和 Snappy 压缩协议


## 三、总结
Kafka 速度的秘诀在于，它把`所有的消息都变成一个批量的文件`，并且进行合理的批量压缩，
减少网络 IO 损耗，通过 `mmap` 提高 I/O 速度，写入数据的时候由于单个 Partion 是末尾添加所以速度最优；
读取数据的时候配合 `sendfile` 直接暴力输出。
