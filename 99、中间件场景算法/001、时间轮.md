

# 时间轮算法

## 时间轮算法的核心思想

只需要把任务放到`它需要被执行的时刻`，然后等到`时针转到相应的位置时`，取出该时刻放置的任务，执行就可以了。

## [概述](https://www.jianshu.com/p/02646eb552ae)

时间轮算法是通过一个`时间轮`去维护定时任务，按照一定的`时间单位`对时间轮进行`划分刻度`。
然后根据任务的延时`计算任务该落在时间轮的第几个刻度`，如果任务时长超出了时间轮的刻度数量，则增加一个参数记录时间轮需要`转动的圈数`。

时间轮每转动一次就检查当前刻度下的`任务圈数是否为0`，如果为0说明时间到了就执行任务，否则就`减少任务的圈数`。

这样看起来已经很好了，可以满足基本的定时任务需求了，但是我们还能不能继续优化一下呢？
答案是可以的。想想我们`家里的水表`，它是不是有多个轮子在转动，时间轮是不是也可以改造成多级联动呢？
建立3个时间轮，月轮、周轮、日轮，月轮存储每个月份需要执行定时任务，
转动时将当月份的任务抛到周轮，周轮转动时将当天的任务抛到日轮中，日轮转动时直接执行当前刻度下的定时任务。



## 例子
时间轮算法可以类比于时钟，如上图箭头(指针)按某一个方向按固定频率轮动，每一次跳动称为一个 tick。

这样可以看出定时轮由个 3 个重要的属性参数，ticksPerWheel(一轮的 tick 数)，tickDuration(一个 tick 的持续时间)以及 timeUnit(时间单位)。

例如当 ticksPerWheel=60，tickDuration=1，timeUnit=秒，这就和现实中的始终的秒针走动完全类似了。

如果当前指针指在 1 上面，我有一个任务需要 4 秒以后执行，那么这个执行的线程回调或者消息将会被放在 5 上。

那如果需要在 20 秒之后执行怎么办，由于这个环形结构槽数只到 8，如果要 20 秒，指针需要多转 2 圈。位置是在 2 圈之后的 5 上面(20 % 8 + 1)。

实现：我们用 Netty 的 HashedWheelTimer 来实现



## 时间轮至少需要提供4个功能

- 1、加入任务 
- 2、执行任务 
- 3、删除任务 (如果哪一天这个任务不需要再执行了，那么直接通知时间轮，找到这个任务的位置删除掉)
- 4、沿着时间刻度前进


## 时间轮的数据结构

时钟可以使用`数组`来表示，那么时钟的每一个刻度就是一个槽，
槽用来存在该刻度需要被执行的定时任务。
正常业务中，同一时刻中是会存在多个定时任务的，所以每个槽中放一个`链表`或者`队列`就可以了，执行的时候遍历一遍即可。


![image](https://github.com/hi-mamba/middleware-learning/assets/7867225/a8be4c82-2e52-47a5-bf95-503d1bfac6f8)

## 时间刻度不够用

### 增加时间轮的刻度


![image](https://github.com/hi-mamba/middleware-learning/assets/7867225/c8bc835e-797d-41b8-aa4a-e04f64ad06e5)

这样做的缺点:

- 1、时间刻度太多会导致时间轮走到的多数刻度没有任务执行，比如一个月就2个任务，我得移动720次，其中718次是无用功。
- 2、时间刻度太多会导致存储空间变大，利用率变低，比如一个月就2个任务，我得需要大小是720的数组，如果我的执行时间的粒度精确到秒，那就更恐怖了。


### 任务增加round属性

现在时间轮的刻度还沿用24，但是槽中的每个任务增加一个round属性，代表时钟转过第几圈之后再次转到这个槽的时候执行。
![image](https://github.com/hi-mamba/middleware-learning/assets/7867225/b0b50ef8-dcac-4c10-8c49-2d7b37fcff35)


上图代表任务三在指针下一圈移动时执行，整体流程就是时间轮没移动一个刻度的时候都要遍历槽中所有任务，
对每个任务的round属性减1，并取出round为0的任务调度，这样可以解决增加时间轮带来的空间浪费。
但是这样带来的问题时，每次移动刻度的耗时会增加，当时间刻度很小(秒级甚至毫秒级)，任务列表有很长，这种方案是不能接受的。


### 分层时间轮

分层时间轮是这样一种思想：

- 1、针对时间复杂度的问题：不做遍历计算round，凡是任务列表中的都应该是应该被执行的，直接全部取出来执行。
- 2、针对空间复杂度的问题：分层，每个时间粒度对应一个时间轮，多个时间轮之间进行级联协作。


![image](https://github.com/hi-mamba/middleware-learning/assets/7867225/d818853f-f4d7-4865-bfe2-2a58c960bf15)

### round时间轮和分层时间轮的一点比较

相比于round时间轮思想，采用分层时间轮算法的优点在于：只需要多耗费极少的空间（从1个时间轮到3个时间轮），
就能实现多线程在效率上的提高（一个时间轮是一个线程去行走，3个时间轮可以3个线程行走）。

当然这是相对的，若提交的任务都是每隔几个小时重复执行，那显然`小时时间轮`比月、周、小时时间轮组合的`耗费空间少`，且执行时间还相同。

## 时间轮的应用

各种操作系统的定时任务调度，Crontab、Dubbo、新版的XXL-JOB、还有基于java的通信框架Netty中也有时间轮的实现，
几乎所有的时间任务调度系统采用的都是时间轮的思想。

 




